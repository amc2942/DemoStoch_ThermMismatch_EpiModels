---
title: "Modeling Demographic Stochasticity and Thermal Mismatch in Host-Pathogen Wildlife Systems"
subtitle: "Modeling Code"
author: "Andy Carlino"
fig-align: center
format:
  pdf: 
    documentclass: article
    geometry: 
        - top=1in
        - left=0.75in
        - bottom=1in
        - right=0.75in
    latex_engine: xelatex  
fontsize: 10pt
mainfont: "Times New Roman" 
date: "`r Sys.Date()`"
editor: source
---

# Setup:

Working Directory and Libraries:
```{r, warning=FALSE}
# Working Directory
setwd("C:\\Users\\andre\\OneDrive\\Documents\\GitHub\\DemoStoch_ThermMismatch_EpiModels")

# Libraries
library(tidyverse)
library(tidyr)
library(ggplot2)
library(stats)
library(reshape2)
library(grid)
library(gridExtra)
library(dplyr)
library(viridis)
```

Source Functions:
```{r}
# Tau leap function
source("tau_leap_function.R")

# Simulation of the within-host model function
source("model_simulation_function.R")
```


# Quadratic Functions for Parameter Values along Thermal Gradient:

Thermal Performance Curve using a Quadratic function: 
$$ 
\text{Parameter} = -q * [\text{temp} - t_{min}][\text{temp} - t_{max}]
$$

Min-Max Normalization to get all parameters on 0-1 scale for easier visualization
$$
\text{Normalized Parameter} = \frac{value - min}{max - min}
$$

```{r}
# Generate temperature range
temperatures <- seq(4, 21, length.out = 50)
```

Estimating the Range of Parameter Phi (pathogen Replication Rate)
```{r}
estimate_phi <- function(temperature, q_phi, tmin_phi, tmax_phi) {
  # Quadratic equation
  phi <- pmax(-q_phi * (temperature - tmin_phi) * (temperature - tmax_phi), 0) 
  return(phi)
}

# Set q for phi
q_phi <- 0.0135
# Set temperature range
tmin_phi <- 1
tmax_phi <- 30

# Calculate corresponding values of phi
phi_values <- estimate_phi(temperatures, q_phi, tmin_phi, tmax_phi)

# Min-Max normalization
norm_phi <- (phi_values - min(phi_values)) / (max(phi_values) - min(phi_values))

# Peak value of the phi Parameter
temp_peak_phi <- (tmin_phi + tmax_phi) / 2
peak_phi <- estimate_phi(temp_peak_phi, q_phi, tmin_phi, tmax_phi)
```

Estimating the Range of Parameter Alpha (Mass-action Attack Rate)
```{r}
estimate_alpha <- function(temperature, q_alpha, tmin_alpha, tmax_alpha){
  # Quadratic Equation
  alpha <- pmax(-q_alpha * (temperature - tmin_alpha) * (temperature - tmax_alpha), 0)
  return(alpha)
}

# Set q value for alpha 
q_alpha <- 0.01375
# Set temperature range
tmin_alpha <- -5
tmax_alpha <- 24

# Calculate corresponding values of alpha
alpha_values <- estimate_alpha(temperatures, q_alpha, tmin_alpha, tmax_alpha)

# Min-Max Normalization
norm_alpha <- (alpha_values - min(alpha_values)) / (max(alpha_values) - min(alpha_values))

# Peak value of the alpha Parameter
temp_peak_alpha <- (tmin_alpha + tmax_alpha) / 2
peak_alpha <- estimate_alpha(temp_peak_alpha, q_alpha, tmin_alpha, tmax_alpha)
```

Estimating the range of other parameters can be easily achieved by copying the code and replacing with appropriate variable names.

Plot the functions: 
```{r}
plot_data <- data.frame(Temperature = temperatures,
                        Phi = norm_phi, 
                        Alpha = norm_alpha)
                        #Psi = psi_values)

# Plot Phi Values
phi_plot <- ggplot(plot_data, aes(x = Temperature, y = Phi)) +
  geom_line(color = "red") + 
  labs(x = "Temperature (°C)", y = "Phi (Pathogen) Values") + 
  geom_vline(xintercept = temp_peak_phi, color = "red", linetype = "dashed") + 
  theme_bw() +
  ggtitle("Temperature vs. Parameter Values") +
  theme(plot.title = element_text(hjust = 0.5)) +
  theme(plot.title = element_text(size = 20)) + 
  theme(axis.text = element_text(size = 15)) + 
  theme(axis.title = element_text(size = 15))

# Plot Alpha Values
alpha_plot <- ggplot(plot_data, aes(x = Temperature, y = Alpha)) +
  geom_line(color = "blue") + 
  labs(x = "Temperature (°C)", y = "Alpha (Host) Values") + 
  geom_vline(xintercept = temp_peak_alpha, color = "blue", linetype = "dashed") +
  theme_bw() + 
  theme(axis.text = element_text(size = 15)) + 
  theme(axis.title = element_text(size = 15))


# To plot both parameters together with normalized values: 
plot_data_long <- plot_data %>% pivot_longer(cols = c(Phi, Alpha), names_to = "Parameter", values_to = "Value")

combined_plot <- ggplot(plot_data_long, aes(x = Temperature, y = Value, color = Parameter)) +
  geom_line() +
  geom_vline(xintercept = temp_peak_phi, color = "red", linetype = "dashed") + # For Phi peak
  geom_vline(xintercept = temp_peak_alpha, color = "blue", linetype = "dashed") + # For Alpha peak
  labs(x = "Temperature (°C)", y = "Parameter Values") +
  theme_bw() +
  ggtitle("Temperature vs. Parameter Values") +
  theme(plot.title = element_text(hjust = 0.5, size = 20),
        axis.text = element_text(size = 15),
        axis.title = element_text(size = 15)) +
  scale_color_manual(values = c("Phi" = "red", "Alpha" = "blue"))

combined_plot
```


## Testing Multiple Scenarios (High, Mid [multiple], Null)
Using this format, we're going to create and test different scenarios, incrementally closing the gap between thermal optima (by bringing tmin/tmax closer for each step), ultimately testing a 'null' scenario where thermal optima completely overlap (i.e., no thermal mismatch). 

#### High Mismatch
```{r}
# FIRST: Phi value for High Mismatch
# Set temperature range (High)
tmin_phi_high <- 1
tmax_phi_high <- 30

# Calculate corresponding values of phi
phi_values_high <- estimate_phi(temperatures, q_phi, tmin_phi_high, tmax_phi_high)

# Min-Max normalization
norm_phi_high <- (phi_values_high - min(phi_values_high)) / (max(phi_values_high) - min(phi_values_high))

# Peak value of the phi Parameter
temp_peak_phi_high <- (tmin_phi_high + tmax_phi_high) / 2
peak_phi_high <- estimate_phi(temp_peak_phi_high, q_phi, tmin_phi_high, tmax_phi_high)

# ------------------------------------------------
# NEXT: Alpha value for High Mismatch
# Set temperature range
tmin_alpha_high <- -5
tmax_alpha_high <- 24

# Calculate corresponding values of alpha
alpha_values_high <- estimate_alpha(temperatures, q_alpha, tmin_alpha_high, tmax_alpha_high)

# Min-Max Normalization
norm_alpha_high <- (alpha_values_high - min(alpha_values_high)) / (max(alpha_values_high) - min(alpha_values_high))

# Peak value of the alpha Parameter
temp_peak_alpha_high <- (tmin_alpha_high + tmax_alpha_high) / 2
peak_alpha_high <- estimate_alpha(temp_peak_alpha_high, q_alpha, tmin_alpha_high, tmax_alpha_high)
```


#### Mid 1 Mismatch
```{r}
# FIRST: Phi value for Mid 1 Mismatch
# Set temperature range
tmin_phi_mid1 <- 0.25
tmax_phi_mid1 <- 29.25

# Calculate corresponding values of phi
phi_values_mid1 <- estimate_phi(temperatures, q_phi, tmin_phi_mid1, tmax_phi_mid1)

# Min-Max normalization
norm_phi_mid1 <- (phi_values_mid1 - min(phi_values_mid1)) / (max(phi_values_mid1) - min(phi_values_mid1))

# Peak value of the phi Parameter
temp_peak_phi_mid1 <- (tmin_phi_mid1 + tmax_phi_mid1) / 2
peak_phi_mid1 <- estimate_phi(temp_peak_phi_mid1, q_phi, tmin_phi_mid1, tmax_phi_mid1)

# ------------------------------------------------
# NEXT: Alpha value for Mid 1 Mismatch
# Set temperature range
tmin_alpha_mid1 <- -4.25
tmax_alpha_mid1 <- 24.75

# Calculate corresponding values of alpha
alpha_values_mid1 <- estimate_alpha(temperatures, q_alpha, tmin_alpha_mid1, tmax_alpha_mid1)

# Min-Max Normalization
norm_alpha_mid1 <- (alpha_values_mid1 - min(alpha_values_mid1)) / (max(alpha_values_mid1) - min(alpha_values_mid1))

# Peak value of the alpha Parameter
temp_peak_alpha_mid1 <- (tmin_alpha_mid1 + tmax_alpha_mid1) / 2
peak_alpha_mid1 <- estimate_alpha(temp_peak_alpha_mid1, q_alpha, tmin_alpha_mid1, tmax_alpha_mid1)
```

#### Mid 2 Mismatch
```{r}
# FIRST: Phi value for Mid 2 Mismatch
# Set temperature range 
tmin_phi_mid2 <- -0.5
tmax_phi_mid2 <- 28.5

# Calculate corresponding values of phi
phi_values_mid2 <- estimate_phi(temperatures, q_phi, tmin_phi_mid2, tmax_phi_mid2)

# Min-Max normalization
norm_phi_mid2 <- (phi_values_mid2 - min(phi_values_mid2)) / (max(phi_values_mid2) - min(phi_values_mid2))

# Peak value of the phi Parameter
temp_peak_phi_mid2 <- (tmin_phi_mid2 + tmax_phi_mid2) / 2
peak_phi_mid2 <- estimate_phi(temp_peak_phi_mid2, q_phi, tmin_phi_mid2, tmax_phi_mid2)

# ------------------------------------------------
# NEXT: Alpha value for Mid 2 Mismatch
# Set temperature range
tmin_alpha_mid2 <- -3.5
tmax_alpha_mid2 <- 25.5

# Calculate corresponding values of alpha
alpha_values_mid2 <- estimate_alpha(temperatures, q_alpha, tmin_alpha_mid2, tmax_alpha_mid2)

# Min-Max Normalization
norm_alpha_mid2 <- (alpha_values_mid2 - min(alpha_values_mid2)) / (max(alpha_values_mid2) - min(alpha_values_mid2))

# Peak value of the alpha Parameter
temp_peak_alpha_mid2 <- (tmin_alpha_mid2 + tmax_alpha_mid2) / 2
peak_alpha_mid2 <- estimate_alpha(temp_peak_alpha_mid2, q_alpha, tmin_alpha_mid2, tmax_alpha_mid2)
```

#### Mid 3 Mismatch
```{r}
# FIRST: Phi value for Mid 3 Mismatch
# Set temperature range 
tmin_phi_mid3 <- -1.25
tmax_phi_mid3 <- 27.75

# Calculate corresponding values of phi
phi_values_mid3 <- estimate_phi(temperatures, q_phi, tmin_phi_mid3, tmax_phi_mid3)

# Min-Max normalization
norm_phi_mid3 <- (phi_values_mid3 - min(phi_values_mid3)) / (max(phi_values_mid3) - min(phi_values_mid3))

# Peak value of the phi Parameter
temp_peak_phi_mid3 <- (tmin_phi_mid3 + tmax_phi_mid3) / 2
peak_phi_mid3 <- estimate_phi(temp_peak_phi_mid3, q_phi, tmin_phi_mid3, tmax_phi_mid3)

# ------------------------------------------------
# NEXT: Alpha value for Mid 3 Mismatch
# Set temperature range
tmin_alpha_mid3 <- -2.75
tmax_alpha_mid3 <- 26.25

# Calculate corresponding values of alpha
alpha_values_mid3 <- estimate_alpha(temperatures, q_alpha, tmin_alpha_mid3, tmax_alpha_mid3)

# Min-Max Normalization
norm_alpha_mid3 <- (alpha_values_mid3 - min(alpha_values_mid3)) / (max(alpha_values_mid3) - min(alpha_values_mid3))

# Peak value of the alpha Parameter
temp_peak_alpha_mid3 <- (tmin_alpha_mid3 + tmax_alpha_mid3) / 2
peak_alpha_mid3 <- estimate_alpha(temp_peak_alpha_mid3, q_alpha, tmin_alpha_mid3, tmax_alpha_mid3)
```

#### No Mismatch (i.e., Null Scenario)
```{r}
# FIRST: Phi value for No Mismatch
# Set temperature range 
tmin_phi_null <- -2
tmax_phi_null <- 27

# Calculate corresponding values of phi
phi_values_null <- estimate_phi(temperatures, q_phi, tmin_phi_null, tmax_phi_null)

# Min-Max normalization
norm_phi_null <- (phi_values_null - min(phi_values_null)) / (max(phi_values_null) - min(phi_values_null))

# Peak value of the phi Parameter
temp_peak_phi_null <- (tmin_phi_null + tmax_phi_null) / 2
peak_phi_null <- estimate_phi(temp_peak_phi_null, q_phi, tmin_phi_null, tmax_phi_null)

# ------------------------------------------------
# NEXT: Alpha value for No Mismatch
# Set temperature range
tmin_alpha_null <- -2
tmax_alpha_null <- 27

# Calculate corresponding values of alpha
alpha_values_null <- estimate_alpha(temperatures, q_alpha, tmin_alpha_null, tmax_alpha_null)

# Min-Max Normalization
norm_alpha_null <- (alpha_values_null - min(alpha_values_null)) / (max(alpha_values_null) - min(alpha_values_null))

# Peak value of the alpha Parameter
temp_peak_alpha_null <- (tmin_alpha_null + tmax_alpha_null) / 2
peak_alpha_null <- estimate_alpha(temp_peak_alpha_null, q_alpha, tmin_alpha_null, tmax_alpha_null)
```

Set the Temperatures we want to check individual simulations: 
```{r}
# Set temperatures to check: 
temp_checks <- c(9.5, 12.5, 15.5)
temp_check_data <- data.frame(Temperature = temp_checks)
```


#### Now we can plot the scenarios: 
```{r, fig.height = 10, fig.width = 5, warning=FALSE}
param_function_plot_data <- data.frame(
  Temperature = rep(temperatures, 5), 
  Normalized_Phi = c(norm_phi_high, norm_phi_mid1, norm_phi_mid2, norm_phi_mid3, norm_phi_null), 
  Normalized_Alpha = c(norm_alpha_high, norm_alpha_mid1, norm_alpha_mid2, norm_alpha_mid3, norm_alpha_null),
  Scenario = factor(rep(c("High Mismatch", "Mid 1 Mismatch", "Mid 2 Mismatch", "Mid 3 Mismatch", "No Mismatch"), each = length(temperatures)))
)

optimal_temps <- data.frame(
  Scenario = factor(c("High Mismatch", "Mid 1 Mismatch", "Mid 2 Mismatch", "Mid 3 Mismatch", "No Mismatch")),
  Temp_Peak_Phi_opt = c(temp_peak_phi_high, temp_peak_phi_mid1, temp_peak_phi_mid2, temp_peak_phi_mid3, temp_peak_phi_null),
  Temp_Peak_Alpha_opt = c(temp_peak_alpha_high, temp_peak_alpha_mid1, temp_peak_alpha_mid2, temp_peak_alpha_mid3, temp_peak_alpha_null)
)

# pivot for ggplot
param_function_plot_data_long <- param_function_plot_data %>% 
  pivot_longer(cols = c(Normalized_Phi, Normalized_Alpha), 
               names_to = "Parameter", values_to = "Normalized_Value")

quad_param_plot_data <- merge(param_function_plot_data_long, optimal_temps, by = "Scenario")
quad_param_plot_data$Parameter <- factor(quad_param_plot_data$Parameter, 
                                          levels = c("Normalized_Phi", "Normalized_Alpha"))

# Create the plot
quad_param_plot <- ggplot(quad_param_plot_data, 
                          aes(x = Temperature, y = Normalized_Value, color = Parameter)) + 
  geom_line(linewidth = 1) + 
  facet_wrap(~ Scenario, ncol = 1,
             labeller = labeller(Scenario = c("No Mismatch" = "No Mismatch (Functions Overlap)",
                                              "High Mismatch" = "High Mismatch (6°C difference)",
                                              "Mid 1 Mismatch" = "Mid 1 Mismatch (4.5°C difference)", 
                                              "Mid 2 Mismatch" = "Mid 2 Mismatch (3°C difference)",
                                              "Mid 3 Mismatch" = "Mid 3 Mismatch (1.5°C difference)"))) +
  scale_color_manual(values = c("Normalized_Phi" = "red", "Normalized_Alpha" = "blue"),
                     labels = c("Phi (Pathogen)", "Alpha (Host)")) + 
  geom_vline(data = temp_check_data, aes(xintercept = Temperature), 
             linetype = "dashed", color = "black", alpha = 0.8) +
  geom_text(data = temp_check_data, 
            aes(x = Temperature, 
                y = min(quad_param_plot_data$Normalized_Value) - 0.05,  # Adjust this value to move labels lower
                label = paste0(Temperature, "°C")),
            hjust = 1.1,  # Move labels to the left of the line
            vjust = 0,   # Center labels vertically
            angle = 0,     # Remove angle
            color = "black", 
            size = 4.5) +
  xlim(4,21) + 
  theme_bw() + 
  labs(x = "Temperature (°C)", y = "Parameter Values (Normalized)", 
       color = " ", title = "A. Thermal Mismatch Scenarios") +
  theme(strip.text = element_text(size = 17), 
        legend.position = "bottom",
        plot.title = element_text(hjust = 0.5, size = 22, face = "bold"),
        axis.title = element_text(size = 18),
        axis.text = element_text(size = 17),
        legend.text = element_text(size = 17))

quad_param_plot

#ggsave("Figures/quad_param_plot.pdf", plot = quad_param_plot,
#       device = "pdf", width = 5, height = 10)
```

# Running the Model (Multiple Temperatures and Multiple Scenarios)

First, setup the code to run model simulations. Then use the parameter values (for phi and alpha) calculated above to run the model at the different scenarios and along the thermal gradient. 

Initial setup of universal variables/parameters: 
```{r}
# Set time/tau: 
tau <- 1 # leap size
t_max <- 40 # days
n_times <- floor(t_max/tau)
t_vec <- seq(1, t_max, length.out = n_times)

# Vector to store Viral and Immune Load
V_vec <- vector(mode = "numeric", length = n_times)
Z_vec <- vector(mode = "numeric", length = n_times)

z_scalar <- 1000

death_threshold <- 3000
clearance_threshold <- 0

# Set initial values
V_vec[1] <- 290                    # Initial viral density 
Z_vec[1] <- rpois(1, 0.35*z_scalar)  # Initial immune component density 

# Set number of iterations per scenario per temperature: 
num_sims <- 100
```

#### High mismatch
```{r, warning=FALSE}
# Store results for high mismatch: 
results_high <- list()

# Data frame to store parameter values
param_values_high <- data.frame(
  Temperature = numeric(),
  Phi = numeric(),
  Alpha = numeric()
)

# Loop through each set temperature for high mismatch scenario: 
for (temp in temp_checks) {
  
  # Temp-specific parameters: 
  phi_high <- estimate_phi(temp, q_phi, tmin_phi_high, tmax_phi_high)
  alpha_high <- estimate_alpha(temp, q_phi, tmin_alpha_high, tmax_alpha_high)

  # store parameters for later use
  param_values_high <- rbind(param_values_high, data.frame(
    Temperature = temp,
    Phi = phi_high,
    Alpha = alpha_high
  ))

  # All Parms: 
  params_high <- list(
    phi = phi_high,
    alpha = alpha_high,
    delta = 1.29,            
    psi = 0.92,              
    gamma = 0.13,            
    N_z = 1.29 * 0.35,       
    z_scalar = z_scalar
  )
  
  # Initialize a list to store simulation results for the current temperature
  temp_results_high <- vector("list", num_sims)
  
  # Run model for all simulations: 
  for (sim in 1:num_sims) {
    sim_results <- model_simulation(
      V_vec = V_vec, 
      Z_vec = Z_vec, 
      params = params_high,
      death_threshold = death_threshold,
      clearance_threshold = clearance_threshold
    )
    
    # Store the simulation results as a list
    temp_results_high[[sim]] <- list(Simulation = sim, 
                                     V_vec = sim_results$V_vec, 
                                     Z_vec = sim_results$Z_vec)
  }
  
  # Convert the list of simulation results to a data frame
  temp_results_high_df <- do.call(rbind, lapply(temp_results_high, as.data.frame))
  
  # Add results for this temperature to the overall list
  results_high[[paste0("Temp", temp)]] <- temp_results_high_df
}

```

#### Mid 1 Mismatch
```{r, warning=FALSE}
set.seed(20)
# Store results for mid 1 mismatch: 
results_mid1 <- list()

# Data frame to store parameter values
param_values_mid1 <- data.frame(
  Temperature = numeric(),
  Phi = numeric(),
  Alpha = numeric()
)

# Loop through each set temperature for mid 1 mismatch scenario: 
for (temp in temp_checks) {
  
  # Temp-specific parameters: 
  phi_mid1 <- estimate_phi(temp, q_phi, tmin_phi_mid1, tmax_phi_mid1)
  alpha_mid1 <- estimate_alpha(temp, q_alpha, tmin_alpha_mid1, tmax_alpha_mid1)
  
  # store parameters for later use
  param_values_mid1 <- rbind(param_values_mid1, data.frame(
  Temperature = temp,
  Phi = phi_mid1,
  Alpha = alpha_mid1
))
  
  # All Parms: 
  params_mid1 <- list(
    phi = phi_mid1,
    alpha = alpha_mid1,
    delta = 1.29,            
    psi = 0.92,              
    gamma = 0.13,            
    N_z = 1.29 * 0.35,       
    z_scalar = z_scalar
  )
  
  # Initialize a list to store simulation results for the current temperature
  temp_results_mid1 <- vector("list", num_sims)
  
  # Run model for all simulations: 
  for (sim in 1:num_sims) {
    sim_results <- model_simulation(
      V_vec = V_vec, 
      Z_vec = Z_vec, 
      params = params_mid1,
      death_threshold = death_threshold,
      clearance_threshold = clearance_threshold
    )
    
    # Store the simulation results as a list
    temp_results_mid1[[sim]] <- list(Simulation = sim, 
                                     V_vec = sim_results$V_vec, 
                                     Z_vec = sim_results$Z_vec)
  }
  
  # Convert the list of simulation results to a data frame
  temp_results_mid1_df <- do.call(rbind, lapply(temp_results_mid1, as.data.frame))
  
  # Add results for this temperature to the overall list
  results_mid1[[paste0("Temp", temp)]] <- temp_results_mid1_df
}

```

#### Mid 2 Mismatch
```{r, warning=FALSE}
# Store results for mid 2 mismatch: 
results_mid2 <- list()

# Data frame to store parameter values
param_values_mid2 <- data.frame(
  Temperature = numeric(),
  Phi = numeric(),
  Alpha = numeric()
)

# Loop through each set temperature for mid 2 mismatch scenario: 
for (temp in temp_checks) {
  
  # Temp-specific parameters: 
  phi_mid2 <- estimate_phi(temp, q_phi, tmin_phi_mid2, tmax_phi_mid2)
  alpha_mid2 <- estimate_alpha(temp, q_alpha, tmin_alpha_mid2, tmax_alpha_mid2)
  
  # store parameters for later use
  param_values_mid2 <- rbind(param_values_mid2, data.frame(
  Temperature = temp,
  Phi = phi_mid2,
  Alpha = alpha_mid2
))
  
  # All Parms: 
  params_mid2 <- list(
    phi = phi_mid2,
    alpha = alpha_mid2,
    delta = 1.29,            
    psi = 0.92,              
    gamma = 0.13,            
    N_z = 1.29 * 0.35,       
    z_scalar = z_scalar
  )
  
  # Initialize a list to store simulation results for the current temperature
  temp_results_mid2 <- vector("list", num_sims)
  
  # Run model for all simulations: 
  for (sim in 1:num_sims) {
    sim_results <- model_simulation(
      V_vec = V_vec, 
      Z_vec = Z_vec, 
      params = params_mid2,
      death_threshold = death_threshold,
      clearance_threshold = clearance_threshold
    )
    
    # Store the simulation results as a list
    temp_results_mid2[[sim]] <- list(Simulation = sim, 
                                     V_vec = sim_results$V_vec, 
                                     Z_vec = sim_results$Z_vec)
  }
  
  # Convert the list of simulation results to a data frame
  temp_results_mid2_df <- do.call(rbind, lapply(temp_results_mid2, as.data.frame))
  
  # Add results for this temperature to the overall list
  results_mid2[[paste0("Temp", temp)]] <- temp_results_mid2_df
}
```

#### Mid 3 Mismatch
```{r, warning=FALSE}
# Store results for mid 3 mismatch: 
results_mid3 <- list()

# Data frame to store parameter values
param_values_mid3 <- data.frame(
  Temperature = numeric(),
  Phi = numeric(),
  Alpha = numeric()
)

# Loop through each set temperature for mid 3 mismatch scenario: 
for (temp in temp_checks) {
  
  # Temp-specific parameters: 
  phi_mid3 <- estimate_phi(temp, q_phi, tmin_phi_mid3, tmax_phi_mid3)
  alpha_mid3 <- estimate_alpha(temp, q_alpha, tmin_alpha_mid3, tmax_alpha_mid3)
  
  # store parameters for later use
  param_values_mid3 <- rbind(param_values_mid3, data.frame(
  Temperature = temp,
  Phi = phi_mid3,
  Alpha = alpha_mid3
))
  
  # All Parms: 
  params_mid3 <- list(
    phi = phi_mid3,
    alpha = alpha_mid3,
    delta = 1.29,            
    psi = 0.92,              
    gamma = 0.13,            
    N_z = 1.29 * 0.35,       
    z_scalar = z_scalar
  )
  
  # Initialize a list to store simulation results for the current temperature
  temp_results_mid3 <- vector("list", num_sims)
  
  # Run model for all simulations: 
  for (sim in 1:num_sims) {
    sim_results <- model_simulation(
      V_vec = V_vec, 
      Z_vec = Z_vec, 
      params = params_mid3,
      death_threshold = death_threshold,
      clearance_threshold = clearance_threshold
    )
    
    # Store the simulation results as a list
    temp_results_mid3[[sim]] <- list(Simulation = sim, 
                                     V_vec = sim_results$V_vec, 
                                     Z_vec = sim_results$Z_vec)
  }
  
  # Convert the list of simulation results to a data frame
  temp_results_mid3_df <- do.call(rbind, lapply(temp_results_mid3, as.data.frame))
  
  # Add results for this temperature to the overall list
  results_mid3[[paste0("Temp", temp)]] <- temp_results_mid3_df
}
```

#### No Mismatch (i.e., Null hypothesis)
```{r, warning=FALSE}
# Store results for mid 2 mismatch: 
results_null <- list()

# Data frame to store parameter values
param_values_null <- data.frame(
  Temperature = numeric(),
  Phi = numeric(),
  Alpha = numeric()
)

# Loop through each set temperature for mid 2 mismatch scenario: 
for (temp in temp_checks) {
  # Temp-specific parameters: 
  phi_null <- estimate_phi(temp, q_phi, tmin_phi_null, tmax_phi_null)
  alpha_null <- estimate_alpha(temp, q_alpha, tmin_alpha_null, tmax_alpha_null)
  
  # store parameters for later use
  param_values_null <- rbind(param_values_null, data.frame(
  Temperature = temp,
  Phi = phi_null,
  Alpha = alpha_null
))
  
  # All Parms: 
  params_null <- list(
    phi = phi_null,
    alpha = alpha_null,
    delta = 1.29,            
    psi = 0.92,              
    gamma = 0.13,            
    N_z = 1.29 * 0.35,       
    z_scalar = z_scalar
  )
  
  # Initialize a list to store simulation results for the current temperature
  temp_results_null <- vector("list", num_sims)
  
  # Run model for all simulations: 
  for (sim in 1:num_sims) {
    sim_results <- model_simulation(
      V_vec = V_vec, 
      Z_vec = Z_vec, 
      params = params_null,
      death_threshold = death_threshold,
      clearance_threshold = clearance_threshold
    )
    
    # Store the simulation results as a list
    temp_results_null[[sim]] <- list(Simulation = sim, 
                                     V_vec = sim_results$V_vec, 
                                     Z_vec = sim_results$Z_vec)
  }
  
  # Convert the list of simulation results to a data frame
  temp_results_null_df <- do.call(rbind, lapply(temp_results_null, as.data.frame))
  
  # Add results for this temperature to the overall list
  results_null[[paste0("Temp", temp)]] <- temp_results_null_df
}
```

#### Combine all the parameter values into one dataframe:
```{r}
all_param_values <- rbind(
  cbind(Scenario = "High Mismatch", param_values_high),
  cbind(Scenario = "Mid 1 Mismatch", param_values_mid1),
  cbind(Scenario = "Mid 2 Mismatch", param_values_mid2),
  cbind(Scenario = "Mid 3 Mismatch", param_values_mid3),
  cbind(Scenario = "No Mismatch", param_values_null)
)
```



#### Create plot with all results (5 Scenarios, 3 Temps each)
```{r}
# Function to combine the results
combine_results <- function(results_list, scenario_name){
  do.call(rbind, lapply(names(results_list), function(temp_name){
    temp_data <- results_list[[temp_name]]
    temp_data$Scenario <- scenario_name
    temp_data$Temperature <- as.numeric(gsub("Temp", "", temp_name))
    return(temp_data)
  }))
}

# All scenarios to one data frame
all_combined_results <- rbind(
  combine_results(results_high, "High"),
  combine_results(results_mid1, "Mid1"),
  combine_results(results_mid2, "Mid2"),
  combine_results(results_mid3, "Mid3"),
  combine_results(results_null, "No")
)

# Summary stats for Confidence intervals and medians for plotting
summary_results <- all_combined_results %>%
  tidyr::unnest(cols = c(V_vec, Z_vec)) %>%
  group_by(Scenario, Temperature) %>%
  mutate(Day = rep(1:40, times = n() / 40)) %>% 
  group_by(Scenario, Temperature, Day) %>%
  summarise(
    V_median = median(V_vec, na.rm = TRUE),
    V_low = quantile(V_vec, 0.025, na.rm = TRUE),
    V_high = quantile(V_vec, 0.975, na.rm = TRUE),
    Z_median = median(Z_vec, na.rm = TRUE),
    Z_low = quantile(Z_vec, 0.025, na.rm = TRUE),
    Z_high = quantile(Z_vec, 0.975, na.rm = TRUE),
    .groups = "drop"
  )
```

Now a plot to show all individual simulations: 
```{r, warning=FALSE, fig.height=10, fig.width=10}
individual_simulations <- all_combined_results %>% 
  tidyr::unnest(cols = c(V_vec, Z_vec)) %>% 
  mutate(Day = rep(1:40, times = n() / 40),
             Simulation_ID = rep(1:100, each = 40, times = length(unique(Scenario)) * length(unique(Temperature)))
)

# Create the plot
scenario_by_temp_plot_individualsims <- ggplot(individual_simulations, aes(x = Day)) +
  # V_vec
  geom_line(aes(y = V_vec, group = interaction(Scenario, Temperature, Simulation_ID), color = "V_vec"),
            alpha = 0.4, linewidth = 0.5) +
  # Z_vec
  geom_line(aes(y = Z_vec, group = interaction(Scenario, Temperature, Simulation_ID), color = "Z_vec"),
            alpha = 0.4, linewidth = 0.5) + 
  # Facet by scenario and temperature
  facet_grid(Scenario ~ Temperature, 
             labeller = labeller(Temperature = function(x) paste0(x, " °C"),
                                 Scenario = function(x) paste0(x, " Mismatch"))) + 
  # Aesthetics:
  scale_color_manual(
    name = " ",
    values = c("V_vec" = "red", "Z_vec" = "blue"),
    labels = c("Pathogen Cell Load [V]", "Immune Cell Load [Z]")
  ) + 
  labs(title = "B. Results by Mismatch Scenario and Temp. (100 Simulations)",
       x = "Days", 
       y = "Within-Host Cell Density/Load") + 
  theme_bw() + 
  theme(legend.position = "bottom", 
        legend.box = "horizontal",
        panel.grid = element_line(color = "gray90"),
        plot.title = element_text(hjust = 0.5, size = 22, face = "bold"),
        axis.title = element_text(size = 19),
        axis.text = element_text(size = 17),
        strip.text = element_text(size = 16),
        legend.text = element_text(size = 17),
        legend.title = element_text(size = 17))

scenario_by_temp_plot_individualsims

#ggsave("Figures/scenario_by_temp_plot_individualsims.pdf", plot = scenario_by_temp_plot_individualsims,
#       device = "pdf", width = 10, height = 10)
```


# Track the Proportion of deaths across thermal gradient and coefficient of variation in clearance days, entropy:

These code blocks will track the proportion of death at each temperature along the sequence, as well as the coefficient of variation in days in which the host clears the pathogen (return NA if no clearance events), as well as the coefficient of variation in death binary(0 no, 1 yes). also trying  entropy to quantify variability. The entropy is defined as the probability-weighted average of the logarithmic probabilities for all possible values (natural log is 'nats' unit):

$$
 \textbf{Entropy} \Rightarrow H(X) = - \sum p(x) * log (p(x))
$$

Smaller temp range: 
```{r}
temperatures_smaller <- seq(9, 16, length.out = 50)
```


#### High Mismatch: 
```{r, warning=FALSE}
# Data frame to store both metrics for high mismatch
pd_cd_results_high <- data.frame(Temperature = temperatures_smaller, 
                                 Proportion_Deaths = NA, 
                                 Entropy = NA, 
                                 Coef_Variation = NA,
                                 Prop_Death_CoefVar = NA,
                                 Crossing_Temperature = NA,
                                 Phi = NA,
                                 Alpha = NA)

# Loop through each temperature
for (temp_idx in seq_along(temperatures_smaller)) {
  temp <- temperatures_smaller[temp_idx]
  
  # Temp-specific parameters
  phi_high <- estimate_phi(temp, q_phi, tmin_phi_high, tmax_phi_high)
  alpha_high <- estimate_alpha(temp, q_alpha, tmin_alpha_high, tmax_alpha_high)
  
  pd_cd_results_high$Phi[temp_idx] <- phi_high
  pd_cd_results_high$Alpha[temp_idx] <- alpha_high
  
  # All parameters
  params_high <- list(
    phi = phi_high,
    alpha = alpha_high,
    delta = 1.29,            
    psi = 0.92,              
    gamma = 0.13,            
    N_z = 1.29 * 0.35,       
    z_scalar = z_scalar
  )
  
  # Initialize counters and storage
  death_count <- 0
  clearance_days <- numeric(num_sims)  # Vector to store clearance days
  
  for (sim in 1:num_sims) {
    sim_results <- model_simulation(
      V_vec = V_vec,
      Z_vec = Z_vec,
      params = params_high, 
      death_threshold = death_threshold,
      clearance_threshold = clearance_threshold
    )
      
    # Check for death *FIRST*
    if (max(sim_results$V_vec, na.rm = TRUE) >= death_threshold) {
      death_count <- death_count + 1
      clearance_days[sim] <- NA
    } else {
      clearance_day <- which(sim_results$V_vec == 0)[1]
      clearance_days[sim] <- ifelse(length(clearance_day) > 0, clearance_day, NA)
    }
  }
  
  # Compute proportion of deaths
  proportion_deaths <- death_count / num_sims
  pd_cd_results_high$Proportion_Deaths[temp_idx] <- proportion_deaths

  # Calculate Entropy (multinomial distribution and using natural logs)
  clearance_count <- sum(!is.na(clearance_days)) # Count clearance events
  death_proportion <- round((death_count / num_sims), 15) #proportion of death events
  clearance_proportion <- round((clearance_count/num_sims), 15) # proportion of clearance events
  persist_proportion <- round((1 - death_proportion - clearance_proportion), 15)
  
  entropy <- 0  # Initialize
  
  # Avoid log(0) issues
  safe_log <- function(x) ifelse(x >= 0.001, log(x), 0)

  # Calculate entropy 
  if (persist_proportion <= 0.01) {
      if (death_proportion <= 0.01 || clearance_proportion <= 0.01) {
        entropy <- 0 # Entropy is 0 if all outcomes are the same
      } else {
        entropy <- - (death_proportion * safe_log(death_proportion) + 
                      clearance_proportion * safe_log(clearance_proportion))
      }
  } else {
      entropy <- - (death_proportion * safe_log(death_proportion) + 
                    clearance_proportion * safe_log(clearance_proportion) +
                    persist_proportion * safe_log(persist_proportion))
  }
  
    
  pd_cd_results_high$Entropy[temp_idx] <- entropy
  
  # Check for crossing 50% threshold (only ONCE per temperature increase)
    if (proportion_deaths >= 0.5 && is.na(pd_cd_results_high$Crossing_Temperature[temp_idx])) { # Check if it crosses 50% AND if we haven't recorded it already
      pd_cd_results_high$Crossing_Temperature[temp_idx] <- temp # Store the temperature at which it crossed 50%
    }
  crossing_temp_high <- pd_cd_results_high$Crossing_Temperature[!is.na(pd_cd_results_high$Crossing_Temperature)][1]

  # Calculate Coefficient of Variation (Only if enough clearances, setting min threshold)
  clearance_days_finite <- clearance_days[!is.na(clearance_days)]
  min_survivors <- 10 

  if (length(clearance_days_finite) >= min_survivors) {
    mean_clearance <- mean(clearance_days_finite)
    sd_clearance <- sd(clearance_days_finite)
    cv <- sd_clearance / mean_clearance
    pd_cd_results_high$Coef_Variation[temp_idx] <- cv
  } else {
    pd_cd_results_high$Coef_Variation[temp_idx] <- NA
    
  }
  
  # Calculate Coef of Variation for Proportion of Deaths
  if (proportion_deaths == 0) {
    prop_death_cv <- 0
  } else {
    prop_deaths_vec <- rep(c(0, 1), times = c(num_sims - death_count, death_count))
  
    min_deaths <- 3  # minimum threshold
  
      if (death_count >= min_deaths) {
          # Bernoulli variance calculation
          variance_prop_deaths <- proportion_deaths * (1 - proportion_deaths) # Correct variance calculation
          sd_prop_deaths <- sqrt(variance_prop_deaths) # Correct SD calculation
          prop_death_cv <- sd_prop_deaths / proportion_deaths # Correct CV calculation
      } else {
          prop_death_cv <- NA
      }
  }

  pd_cd_results_high$Prop_Death_CoefVar[temp_idx] <- prop_death_cv
}

```


#### Mid 1 Mismatch: 
```{r, warning=FALSE}
# Data frame to store both metrics for mid1 mismatch
pd_cd_results_mid1 <- data.frame(Temperature = temperatures_smaller, 
                                 Proportion_Deaths = NA, 
                                 Entropy = NA, 
                                 Coef_Variation = NA,
                                 Prop_Death_CoefVar = NA,
                                 Crossing_Temperature = NA,
                                 Phi = NA,
                                 Alpha = NA)

# Loop through each temperature
for (temp_idx in seq_along(temperatures_smaller)) {
  temp <- temperatures_smaller[temp_idx]
  
  # Temp-specific parameters
  phi_mid1 <- estimate_phi(temp, q_phi, tmin_phi_mid1, tmax_phi_mid1)
  alpha_mid1 <- estimate_alpha(temp, q_alpha, tmin_alpha_mid1, tmax_alpha_mid1)
  
  pd_cd_results_mid1$Phi[temp_idx] <- phi_mid1
  pd_cd_results_mid1$Alpha[temp_idx] <- alpha_mid1
  
  # All parameters
  params_mid1 <- list(
    phi = phi_mid1,
    alpha = alpha_mid1,
    delta = 1.29,            
    psi = 0.92,              
    gamma = 0.13,            
    N_z = 1.29 * 0.35,       
    z_scalar = z_scalar
  )
  
  # Initialize counters and storage
  death_count <- 0
  clearance_days <- numeric(num_sims)  # Vector to store clearance days
  
  for (sim in 1:num_sims) {
    sim_results <- model_simulation(
      V_vec = V_vec,
      Z_vec = Z_vec,
      params = params_mid1, 
      death_threshold = death_threshold,
      clearance_threshold = clearance_threshold
    )
      
    # Check for death *FIRST*
    if (max(sim_results$V_vec, na.rm = TRUE) >= death_threshold) {
      death_count <- death_count + 1
      clearance_days[sim] <- NA
    } else {
      clearance_day <- which(sim_results$V_vec == 0)[1]
      clearance_days[sim] <- ifelse(length(clearance_day) > 0, clearance_day, NA)
    }
  }
  # Compute proportion of deaths
  proportion_deaths <- death_count / num_sims
  pd_cd_results_mid1$Proportion_Deaths[temp_idx] <- proportion_deaths

  # Calculate Entropy (multinomial distribution and using natural logs)
  clearance_count <- sum(!is.na(clearance_days)) # Count clearance events
  death_proportion <- round((death_count / num_sims), 15) #proportion of death events
  clearance_proportion <- round((clearance_count/num_sims), 15) # proportion of clearance events
  persist_proportion <- round((1 - death_proportion - clearance_proportion), 15)
  
  entropy <- 0  # Initialize
  
  # Avoid log(0) issues
  safe_log <- function(x) ifelse(x >= 0.001, log(x), 0)

  # Calculate entropy 
  if (persist_proportion <= 0.01) {
      if (death_proportion <= 0.01 || clearance_proportion <= 0.01) {
        entropy <- 0 # Entropy is 0 if all outcomes are the same
      } else {
        entropy <- - (death_proportion * safe_log(death_proportion) + 
                      clearance_proportion * safe_log(clearance_proportion))
      }
  } else {
      entropy <- - (death_proportion * safe_log(death_proportion) + 
                    clearance_proportion * safe_log(clearance_proportion) +
                    persist_proportion * safe_log(persist_proportion))
  }
  
  
  pd_cd_results_mid1$Entropy[temp_idx] <- entropy
  
  # Check for crossing 50% threshold (only ONCE per temperature increase)
  if (proportion_deaths >= 0.5 && is.na(pd_cd_results_mid1$Crossing_Temperature[temp_idx])) { # Check if it crosses 50% AND if we haven't recorded it already
    pd_cd_results_mid1$Crossing_Temperature[temp_idx] <- temp # Store the temperature at which it crossed 50%
  }
  crossing_temp_mid1 <- pd_cd_results_mid1$Crossing_Temperature[!is.na(pd_cd_results_mid1$Crossing_Temperature)][1]
  
  # Calculate Coefficient of Variation (Only if enough clearances, setting min threshold)
  clearance_days_finite <- clearance_days[!is.na(clearance_days)]
  min_survivors <- 10 

  if (length(clearance_days_finite) >= min_survivors) {
    mean_clearance <- mean(clearance_days_finite)
    sd_clearance <- sd(clearance_days_finite)
    cv <- sd_clearance / mean_clearance
    pd_cd_results_mid1$Coef_Variation[temp_idx] <- cv
  } else {
    pd_cd_results_mid1$Coef_Variation[temp_idx] <- NA
  }
    
  # Calculate Coef of Variation for Proportion of Deaths
  if (proportion_deaths == 0) {
    prop_death_cv <- 0
  } else {
    prop_deaths_vec <- rep(c(0, 1), times = c(num_sims - death_count, death_count))
  
    min_deaths <- 3  # minimum threshold
  
      if (death_count >= min_deaths) {
          # Bernoulli variance calculation
          variance_prop_deaths <- proportion_deaths * (1 - proportion_deaths) # Correct variance calculation
          sd_prop_deaths <- sqrt(variance_prop_deaths) # Correct SD calculation
          prop_death_cv <- sd_prop_deaths / proportion_deaths # Correct CV calculation
      } else {
          prop_death_cv <- NA
      }
  }

  pd_cd_results_mid1$Prop_Death_CoefVar[temp_idx] <- prop_death_cv
}

```


#### Mid 2 Mismatch: 
```{r, warning=FALSE}
# Data frame to store both metrics for mid2 mismatch
pd_cd_results_mid2 <- data.frame(Temperature = temperatures_smaller, 
                                 Proportion_Deaths = NA, 
                                 Entropy = NA, 
                                 Coef_Variation = NA,
                                 Prop_Death_CoefVar = NA,
                                 Crossing_Temperature = NA,
                                 Phi = NA,
                                 Alpha = NA)

# Loop through each temperature
for (temp_idx in seq_along(temperatures_smaller)) {
  temp <- temperatures_smaller[temp_idx]
  
  # Temp-specific parameters
  phi_mid2 <- estimate_phi(temp, q_phi, tmin_phi_mid2, tmax_phi_mid2)
  alpha_mid2 <- estimate_alpha(temp, q_alpha, tmin_alpha_mid2, tmax_alpha_mid2)
  
  pd_cd_results_mid2$Phi[temp_idx] <- phi_mid2
  pd_cd_results_mid2$Alpha[temp_idx] <- alpha_mid2
  
  # All parameters
  params_mid2 <- list(
    phi = phi_mid2,
    alpha = alpha_mid2,
    delta = 1.29,            
    psi = 0.92,              
    gamma = 0.13,            
    N_z = 1.29 * 0.35,       
    z_scalar = z_scalar
  )
  
  # Initialize counters and storage
  death_count <- 0
  clearance_days <- numeric(num_sims)  # Vector to store clearance days
  
  for (sim in 1:num_sims) {
    sim_results <- model_simulation(
      V_vec = V_vec,
      Z_vec = Z_vec,
      params = params_mid2, 
      death_threshold = death_threshold,
      clearance_threshold = clearance_threshold
    )
      
    # Check for death *FIRST*
    if (max(sim_results$V_vec, na.rm = TRUE) >= death_threshold) {
      death_count <- death_count + 1
      clearance_days[sim] <- NA
    } else {
      clearance_day <- which(sim_results$V_vec == 0)[1]
      clearance_days[sim] <- ifelse(length(clearance_day) > 0, clearance_day, NA)
    }
  }
  # Compute proportion of deaths
  proportion_deaths <- death_count / num_sims
  pd_cd_results_mid2$Proportion_Deaths[temp_idx] <- proportion_deaths

  # Calculate Entropy (multinomial distribution and using natural logs)
  clearance_count <- sum(!is.na(clearance_days)) # Count clearance events
  death_proportion <- round((death_count / num_sims), 15) #proportion of death events
  clearance_proportion <- round((clearance_count/num_sims), 15) # proportion of clearance events
  persist_proportion <- round((1 - death_proportion - clearance_proportion), 15)
  
  entropy <- 0  # Initialize
  
  # Avoid log(0) issues
  safe_log <- function(x) ifelse(x >= 0.001, log(x), 0)

  # Calculate entropy 
  if (persist_proportion <= 0.01) {
      if (death_proportion <= 0.01 || clearance_proportion <= 0.01) {
        entropy <- 0 # Entropy is 0 if all outcomes are the same
      } else {
        entropy <- - (death_proportion * safe_log(death_proportion) + 
                      clearance_proportion * safe_log(clearance_proportion))
      }
  } else {
      entropy <- - (death_proportion * safe_log(death_proportion) + 
                    clearance_proportion * safe_log(clearance_proportion) +
                    persist_proportion * safe_log(persist_proportion))
  }
  
  
  pd_cd_results_mid2$Entropy[temp_idx] <- entropy
  
  # Check for crossing 50% threshold (only ONCE per temperature increase)
  if (proportion_deaths >= 0.5 && is.na(pd_cd_results_mid2$Crossing_Temperature[temp_idx])) { # Check if it crosses 50% AND if we haven't recorded it already
    pd_cd_results_mid2$Crossing_Temperature[temp_idx] <- temp # Store the temperature at which it crossed 50%
  }
  crossing_temp_mid2 <- pd_cd_results_mid2$Crossing_Temperature[!is.na(pd_cd_results_mid2$Crossing_Temperature)][1]  
  
  # Calculate Coefficient of Variation (Only if enough clearances, setting min threshold)
  clearance_days_finite <- clearance_days[!is.na(clearance_days)]
  min_survivors <- 10 

  if (length(clearance_days_finite) >= min_survivors) {
    mean_clearance <- mean(clearance_days_finite)
    sd_clearance <- sd(clearance_days_finite)
    cv <- sd_clearance / mean_clearance
    pd_cd_results_mid2$Coef_Variation[temp_idx] <- cv
  } else {
    pd_cd_results_mid2$Coef_Variation[temp_idx] <- NA
  }
  
  # Calculate Coef of Variation for Proportion of Deaths
  if (proportion_deaths == 0) {
    prop_death_cv <- 0
  } else {
    prop_deaths_vec <- rep(c(0, 1), times = c(num_sims - death_count, death_count))
  
    min_deaths <- 3  # minimum threshold
  
      if (death_count >= min_deaths) {
          # Bernoulli variance calculation
          variance_prop_deaths <- proportion_deaths * (1 - proportion_deaths) # Correct variance calculation
          sd_prop_deaths <- sqrt(variance_prop_deaths) # Correct SD calculation
          prop_death_cv <- sd_prop_deaths / proportion_deaths # Correct CV calculation
      } else {
          prop_death_cv <- NA
      }
  }

  pd_cd_results_mid2$Prop_Death_CoefVar[temp_idx] <- prop_death_cv
}

```

#### Mid 3 Mismatch: 
```{r, warning=FALSE}
set.seed(0)
# Data frame to store both metrics for mid3 mismatch
pd_cd_results_mid3 <- data.frame(Temperature = temperatures_smaller, 
                                 Proportion_Deaths = NA, 
                                 Entropy = NA, 
                                 Coef_Variation = NA,
                                 Prop_Death_CoefVar = NA,
                                 Crossing_Temperature = NA,
                                 Phi = NA,
                                 Alpha = NA)

# Loop through each temperature
for (temp_idx in seq_along(temperatures_smaller)) {
  temp <- temperatures_smaller[temp_idx]
  
  # Temp-specific parameters
  phi_mid3 <- estimate_phi(temp, q_phi, tmin_phi_mid3, tmax_phi_mid3)
  alpha_mid3 <- estimate_alpha(temp, q_alpha, tmin_alpha_mid3, tmax_alpha_mid3)
  
  pd_cd_results_mid3$Phi[temp_idx] <- phi_mid3
  pd_cd_results_mid3$Alpha[temp_idx] <- alpha_mid3
  
  # All parameters
  params_mid3 <- list(
    phi = phi_mid3,
    alpha = alpha_mid3,
    delta = 1.29,            
    psi = 0.895,              
    gamma = 0.13,            
    N_z = 1.29 * 0.35,       
    z_scalar = z_scalar
  )
  
  # Initialize counters and storage
  death_count <- 0
  clearance_days <- numeric(num_sims)  # Vector to store clearance days
  
  for (sim in 1:num_sims) {
    sim_results <- model_simulation(
      V_vec = V_vec,
      Z_vec = Z_vec,
      params = params_mid3, 
      death_threshold = death_threshold,
      clearance_threshold = clearance_threshold
    )
      
    # Check for death *FIRST*
    if (max(sim_results$V_vec, na.rm = TRUE) >= death_threshold) {
      death_count <- death_count + 1
      clearance_days[sim] <- NA
    } else {
      clearance_day <- which(sim_results$V_vec == 0)[1]
      clearance_days[sim] <- ifelse(length(clearance_day) > 0, clearance_day, NA)
    }
  }
  # Compute proportion of deaths
  proportion_deaths <- death_count / num_sims
  pd_cd_results_mid3$Proportion_Deaths[temp_idx] <- proportion_deaths

  # Calculate Entropy (multinomial distribution and using natural logs)
  clearance_count <- sum(!is.na(clearance_days)) # Count clearance events
  death_proportion <- round((death_count / num_sims), 15) #proportion of death events
  clearance_proportion <- round((clearance_count/num_sims), 15) # proportion of clearance events
  persist_proportion <- round((1 - death_proportion - clearance_proportion), 15)
  
  entropy <- 0  # Initialize
  
  # Avoid log(0) issues
  safe_log <- function(x) ifelse(x >= 0.001, log(x), 0)

  # Calculate entropy 
  if (persist_proportion <= 0.01) {
      if (death_proportion <= 0.01 || clearance_proportion <= 0.01) {
        entropy <- 0 # Entropy is 0 if all outcomes are the same
      } else {
        entropy <- - (death_proportion * safe_log(death_proportion) + 
                      clearance_proportion * safe_log(clearance_proportion))
      }
  } else {
      entropy <- - (death_proportion * safe_log(death_proportion) + 
                    clearance_proportion * safe_log(clearance_proportion) +
                    persist_proportion * safe_log(persist_proportion))
  }
  
  
  pd_cd_results_mid3$Entropy[temp_idx] <- entropy
  
  # Check for crossing 50% threshold (only ONCE per temperature increase)
  if (proportion_deaths >= 0.5 && is.na(pd_cd_results_mid3$Crossing_Temperature[temp_idx])) { # Check if it crosses 50% AND if we haven't recorded it already
    pd_cd_results_mid3$Crossing_Temperature[temp_idx] <- temp # Store the temperature at which it crossed 50%
  }
  crossing_temp_mid3 <- pd_cd_results_mid3$Crossing_Temperature[!is.na(pd_cd_results_mid3$Crossing_Temperature)][1]  
  
  
  # Calculate Coefficient of Variation (Only if enough clearances, setting min threshold)
  clearance_days_finite <- clearance_days[!is.na(clearance_days)]
  min_survivors <- 10 

  if (length(clearance_days_finite) >= min_survivors) {
    mean_clearance <- mean(clearance_days_finite)
    sd_clearance <- sd(clearance_days_finite)
    cv <- sd_clearance / mean_clearance
    pd_cd_results_mid3$Coef_Variation[temp_idx] <- cv
  } else {
    pd_cd_results_mid3$Coef_Variation[temp_idx] <- NA
  }
  
    
  # Calculate Coef of Variation for Proportion of Deaths
  if (proportion_deaths == 0) {
    prop_death_cv <- 0
  } else {
    prop_deaths_vec <- rep(c(0, 1), times = c(num_sims - death_count, death_count))
  
    min_deaths <- 3  # minimum threshold
  
      if (death_count >= min_deaths) {
          # Bernoulli variance calculation
          variance_prop_deaths <- proportion_deaths * (1 - proportion_deaths) # Correct variance calculation
          sd_prop_deaths <- sqrt(variance_prop_deaths) # Correct SD calculation
          prop_death_cv <- sd_prop_deaths / proportion_deaths # Correct CV calculation
      } else {
          prop_death_cv <- NA
      }
  }
  
  pd_cd_results_mid3$Prop_Death_CoefVar[temp_idx] <- prop_death_cv
}

```

#### Null Mismatch: 
```{r, warning=FALSE}
# Data frame to store both metrics for mid1 mismatch
pd_cd_results_null <- data.frame(Temperature = temperatures_smaller, 
                                 Proportion_Deaths = NA, 
                                 Entropy = NA, 
                                 Coef_Variation = NA,
                                 Prop_Death_CoefVar = NA,
                                 Crossing_Temperature = NA,
                                 Phi = NA,
                                 Alpha = NA)

# Loop through each temperature
for (temp_idx in seq_along(temperatures_smaller)) {
  temp <- temperatures_smaller[temp_idx]
  
  # Temp-specific parameters
  phi_null <- estimate_phi(temp, q_phi, tmin_phi_null, tmax_phi_null)
  alpha_null <- estimate_alpha(temp, q_alpha, tmin_alpha_null, tmax_alpha_null)
  
  pd_cd_results_null$Phi[temp_idx] <- phi_null
  pd_cd_results_null$Alpha[temp_idx] <- alpha_null
  
  # All parameters
  params_null <- list(
    phi = phi_null,
    alpha = alpha_null,
    delta = 1.29,            
    psi = 0.92,              
    gamma = 0.13,            
    N_z = 1.29 * 0.35,       
    z_scalar = z_scalar
  )
  
  # Initialize counters and storage
  death_count <- 0
  clearance_days <- numeric(num_sims)  # Vector to store clearance days
  
  for (sim in 1:num_sims) {
    sim_results <- model_simulation(
      V_vec = V_vec,
      Z_vec = Z_vec,
      params = params_null, 
      death_threshold = death_threshold,
      clearance_threshold = clearance_threshold
    )
      
    # Check for death *FIRST*
    if (max(sim_results$V_vec, na.rm = TRUE) >= death_threshold) {
      death_count <- death_count + 1
      clearance_days[sim] <- NA
    } else {
      clearance_day <- which(sim_results$V_vec == 0)[1]
      clearance_days[sim] <- ifelse(length(clearance_day) > 0, clearance_day, NA)
    }
  }
  # Compute proportion of deaths
  proportion_deaths <- death_count / num_sims
  pd_cd_results_null$Proportion_Deaths[temp_idx] <- proportion_deaths

  # Calculate Entropy (multinomial distribution and using natural logs)
  clearance_count <- sum(!is.na(clearance_days)) # Count clearance events
  death_proportion <- round((death_count / num_sims), 15) #proportion of death events
  clearance_proportion <- round((clearance_count/num_sims), 15) # proportion of clearance events
  persist_proportion <- round((1 - death_proportion - clearance_proportion), 15)
  
  entropy <- 0  # Initialize
  
  # Avoid log(0) issues
  safe_log <- function(x) ifelse(x >= 0.001, log(x), 0)

  # Calculate entropy 
  if (persist_proportion <= 0.01) {
      if (death_proportion <= 0.01 || clearance_proportion <= 0.01) {
        entropy <- 0 # Entropy is 0 if all outcomes are the same
      } else {
        entropy <- - (death_proportion * safe_log(death_proportion) + 
                      clearance_proportion * safe_log(clearance_proportion))
      }
  } else {
      entropy <- - (death_proportion * safe_log(death_proportion) + 
                    clearance_proportion * safe_log(clearance_proportion) +
                    persist_proportion * safe_log(persist_proportion))
  }
  
  
  pd_cd_results_null$Entropy[temp_idx] <- entropy
   
  # Check for crossing 50% threshold (only ONCE per temperature increase)
  if (proportion_deaths >= 0.5 && is.na(pd_cd_results_null$Crossing_Temperature[temp_idx])) { # Check if it crosses 50% AND if we haven't recorded it already
    pd_cd_results_null$Crossing_Temperature[temp_idx] <- temp # Store the temperature at which it crossed 50%
  }
  crossing_temp_null <- pd_cd_results_null$Crossing_Temperature[!is.na(pd_cd_results_null$Crossing_Temperature)][1]  
  
 
  # Calculate Coefficient of Variation (Only if enough clearances, setting min threshold)
  clearance_days_finite <- clearance_days[!is.na(clearance_days)]
  min_survivors <- 10 

  if (length(clearance_days_finite) >= min_survivors) {
    mean_clearance <- mean(clearance_days_finite)
    sd_clearance <- sd(clearance_days_finite)
    cv <- sd_clearance / mean_clearance
    pd_cd_results_null$Coef_Variation[temp_idx] <- cv
  } else {
    pd_cd_results_null$Coef_Variation[temp_idx] <- NA
  }
  
    
  # Calculate Coef of Variation for Proportion of Deaths
  if (proportion_deaths == 0) {
    prop_death_cv <- 0
  } else {
    prop_deaths_vec <- rep(c(0, 1), times = c(num_sims - death_count, death_count))
  
    min_deaths <- 3  # minimum threshold
  
      if (death_count >= min_deaths) {
          # Bernoulli variance calculation
          variance_prop_deaths <- proportion_deaths * (1 - proportion_deaths) # Correct variance calculation
          sd_prop_deaths <- sqrt(variance_prop_deaths) # Correct SD calculation
          prop_death_cv <- sd_prop_deaths / proportion_deaths # Correct CV calculation
      } else {
          prop_death_cv <- NA
      }
  }
  
  pd_cd_results_null$Prop_Death_CoefVar[temp_idx] <- prop_death_cv
}

```

add scenario column to each dataframe: 
```{r}
# Add Scenario column to each data frame and combine
pd_cd_results_high$Scenario <- "High Mismatch"
pd_cd_results_mid1$Scenario <- "Mid 1 Mismatch"
pd_cd_results_mid2$Scenario <- "Mid 2 Mismatch"
pd_cd_results_mid3$Scenario <- "Mid 3 Mismatch"
pd_cd_results_null$Scenario <- "No Mismatch"
```

#### Plot the proportion of death at each scenario
```{r, fig.height=10, fig.width=6, warning=FALSE}
# Combine results to one data.frame
death_data <- data.frame(
  Temperature = rep(temperatures_smaller, times = 5),
  Proportion_Deaths = c(pd_cd_results_high$Proportion_Deaths,
                        pd_cd_results_mid1$Proportion_Deaths,
                        pd_cd_results_mid2$Proportion_Deaths,
                        pd_cd_results_mid3$Proportion_Deaths,
                        pd_cd_results_null$Proportion_Deaths),
  Scenario = rep(c("High Mismatch", "Mid 1 Mismatch", 
                   "Mid 2 Mismatch", "Mid 3 Mismatch", "No Mismatch"), 
                 each = length(temperatures_smaller)),
  Crossing_Temperature = c(rep(crossing_temp_high, length(temperatures_smaller)),
                           rep(crossing_temp_mid1, length(temperatures_smaller)),
                           rep(crossing_temp_mid2, length(temperatures_smaller)),
                           rep(crossing_temp_mid3, length(temperatures_smaller)),
                           rep(crossing_temp_null, length(temperatures_smaller)))

)

death_data$Legend_Label <- "Proportion of Deaths"

# Create the plot
death_plot <- ggplot(death_data, aes(x = Temperature, y = Proportion_Deaths, color = Legend_Label)) +
  geom_line(linewidth = 1) +
  geom_hline(yintercept = 0.5, linetype = "dashed", color = "black", linewidth = 0.8) +
  geom_blank(aes(y = 0.5, color = "50% of Simulations Die")) + # Dummy geom
  scale_color_manual(values = c("Proportion of Deaths" = "purple", "50% of Simulations Die" = "black")) +
  facet_wrap(~ Scenario, ncol = 1) +
  geom_vline(aes(xintercept = Crossing_Temperature), data = death_data, 
             linetype = "dashed", color = "black", linewidth = 0.8) + 
  theme_bw() +
  labs(x = "Temperature (°C)", y = "Proportion of Deaths",
       color = NULL, title = "C. Deaths Across Thermal Gradient") +
  theme(strip.text = element_text(size = 19),
        legend.position = "bottom",
        plot.title = element_text(hjust = 0.5, size = 22, face = "bold"),
        axis.title = element_text(size = 19),
        axis.text = element_text(size = 17),
        legend.text = element_text(size = 16))

death_plot

#ggsave("Figures/death_plot.pdf", plot = death_plot,
#       device = "pdf", width = 7, height = 10)
```


# Plot the ENTROPY for each thermal mismatch scenario
```{r, fig.height=10, fig.width = 6, warning=FALSE}
# data frame for all results and easier ggplotting
ent_data <- data.frame(
  Temperature = rep(temperatures_smaller, times = 5),
  Entropy = c(pd_cd_results_high$Entropy,
                     pd_cd_results_mid1$Entropy,
                     pd_cd_results_mid2$Entropy,
                     pd_cd_results_mid3$Entropy,
                     pd_cd_results_null$Entropy),
  Scenario = rep(c("High Mismatch", "Mid 1 Mismatch", "Mid 2 Mismatch", 
                   "Mid 3 Mismatch", "No Mismatch"), 
                 each = length(temperatures_smaller)),
  Crossing_Temperature = c(rep(crossing_temp_high, length(temperatures_smaller)),
                           rep(crossing_temp_mid1, length(temperatures_smaller)),
                           rep(crossing_temp_mid2, length(temperatures_smaller)),
                           rep(crossing_temp_mid3, length(temperatures_smaller)),
                           rep(crossing_temp_null, length(temperatures_smaller)))
)

ent_data$Legend_Label <- "Entropy"

# create the facetwrapped plot: 
ent_plot <- ggplot(ent_data, aes(x = Temperature, y = Entropy, color = Legend_Label)) +
  geom_line(linewidth = 1) + 
  facet_wrap(~ Scenario, ncol = 1) + 
  geom_blank(aes(y = 0.5, color = "50% of Simulations Die")) + # Dummy geom
  scale_color_manual(values = c("Entropy" = "forestgreen", "50% of Simulations Die" = "black")) +
  geom_vline(aes(xintercept = Crossing_Temperature), data = ent_data, 
             linetype = "dashed", color = "black", linewidth = 0.8) + 
  theme_bw() + 
  labs(x = "Temperature (°C)", y = "Entropy (nats)",
       color = NULL, title = "D. Outcome Variability (Entropy)") + 
  theme(strip.text = element_text(size = 19),
        legend.position = "bottom",
        plot.title = element_text(hjust = 0.5, size = 22, face = "bold"),
        axis.title = element_text(size = 19),
        axis.text = element_text(size = 17),
        legend.text = element_text(size = 17))

ent_plot

#ggsave("Figures/Entropy.pdf", plot = ent_plot,
 #      device = "pdf", width = 6, height = 10)
```

# Display all plots side by side: 
```{r}
p1 <- quad_param_plot
p2 <- scenario_by_temp_plot_individualsims
p3 <- death_plot
p4 <- ent_plot

# setting widths
widths <- c(1.0, 1.75, 1.1, 1.1)
total_width <- sum(widths)
prop1 <- widths[1] / total_width
prop2 <- (widths[1] + widths[2]) / total_width
prop3 <- (widths[1] + widths[2] + widths[3]) / total_width
```

#### Plot with all individual simulations
```{r, warning=FALSE, fig.height=16, fig.width=27}
all_plots_individual_sims <- gridExtra::grid.arrange(
  p1, p2, p3, p4,
  ncol = 4,
  widths = widths, 
  padding = unit(2, "cm")
)

grid.lines(x = c(prop1, prop1), y = c(0, 1),
           gp = gpar(col = "black", lwd = 2))
grid.lines(x = c(prop2, prop2), y = c(0, 1),
           gp = gpar(col = "black", lwd = 2))
grid.lines(x = c(prop3, prop3), y = c(0, 1),
           gp = gpar(col = "black", lwd = 2))
invisible(all_plots_individual_sims)

#ggsave("Figures/FullFigure.pdf", plot = all_plots_individual_sims, 
#       device = "pdf", width = 27, height = 16)
```


# Plot for Heatmap of the Entropy of Model Outcomes with different values of Phi and Alpha

This chunk takes a while to run, 25 x 25 parameter combinations with 100 simulations each....
```{r, warning = FALSE}
# Define synthetic range for phi and alpha
phi_vals_hm <- seq(2.25, 2.9, length.out = 25)
alpha_vals_hm <- seq(2.25, 2.9, length.out = 25)

# Dataframe for grid results
death_prop_grid <- expand.grid(phi = phi_vals_hm, alpha = alpha_vals_hm)
death_prop_grid$Entropy <- NA

# Model run looping through all param combinations
for (i in seq_len(nrow(death_prop_grid))) {
  phi <- death_prop_grid$phi[i]
  alpha <- death_prop_grid$alpha[i]
  
  # Set all params
  params <- list(
    phi = phi,
    alpha = alpha, 
    delta = 1.29,
    psi = 0.91,
    gamma = 0.13,
    N_z = 1.29 * 0.35, 
    z_scalar = z_scalar
  )
  
  death_count <- 0
  clearance_days <- numeric(num_sims) 
  
  for(sim in 1:num_sims) {
    hm_sim_results <- model_simulation(
      V_vec = V_vec,
      Z_vec = Z_vec, 
      params = params, 
      death_threshold = death_threshold,
      clearance_threshold = clearance_threshold
    )
    
    # Check for death
    if (max(hm_sim_results$V_vec, na.rm = TRUE) >= death_threshold) {
      death_count <- death_count + 1
      clearance_days[sim] <- NA
    } else {
      clearance_day <- which(hm_sim_results$V_vec == 0)[1]
      clearance_days[sim] <- ifelse(length(clearance_day) > 0, clearance_day, NA)
    }
  }
  
  # Compute proportions
  clearance_count <- sum(!is.na(clearance_days))
  death_proportion <- round(death_count / num_sims, 5)
  clearance_proportion <- round(clearance_count / num_sims, 5)
  persist_proportion <- round(1 - death_proportion - clearance_proportion, 5)
  
  # Initialize entropy
  entropy <- 0  


  # Avoid log(0) issues
  safe_log <- function(x) ifelse(x >= 0.001, log(x), 0)

  # Calculate entropy 
  if (persist_proportion <= 0.01) {
      if (death_proportion <= 0.01 || clearance_proportion <= 0.01) {
        entropy <- 0 # Entropy is 0 if all outcomes are the same
      } else {
        entropy <- - (death_proportion * safe_log(death_proportion) + 
                      clearance_proportion * safe_log(clearance_proportion))
      }
  } else {
      entropy <- - (death_proportion * safe_log(death_proportion) + 
                    clearance_proportion * safe_log(clearance_proportion) +
                    persist_proportion * safe_log(persist_proportion))
  }
  
  # Store entropy
  death_prop_grid$Entropy[i] <- entropy
}
```

#### Plot (Heatmap with geom_tile)
```{r, warning=FALSE, fig.height=7, fig.width=10}

# ensure the correct ordering:
# NOTE: this is the param values at 9.5, 12.5, 15.5:
all_param_values <- all_param_values %>%
  arrange(Scenario, Temperature) %>% 
  filter(Scenario %in% c("High Mismatch", "Mid 2 Mismatch", "No Mismatch"))

all_param_gradient <- rbind(
  pd_cd_results_high,
  pd_cd_results_mid1,
  pd_cd_results_mid2,
  pd_cd_results_mid3,
  pd_cd_results_null
)

all_param_gradient <- all_param_gradient %>% 
  arrange(Scenario, Temperature) %>% 
  filter(Scenario %in% c("High Mismatch", "Mid 1 Mismatch", "Mid 2 Mismatch", "Mid 3 Mismatch", "No Mismatch"))

# Create a separate data frame for the heatmap
heatmap_data <- death_prop_grid[, c("phi", "alpha", "Entropy")]

phi_alpha_range_plot <- ggplot(heatmap_data, aes(x = phi, y = alpha, fill = Entropy)) +
  geom_tile() +
  scale_fill_viridis_c(option = "viridis", direction = -1) +
  theme_bw() +
  labs(title = "Outcome Variability across a Range of Parameter Values",
       x = expression(paste("Pathogen Replication Rate (", phi, ") Range")),
       y = expression(paste("Mass-Action Attack Rate ( ", alpha, ") Range")),
       fill = "Entropy") +
  theme(plot.title = element_text(size = 17, hjust = 0.5, face = "bold"),
        axis.title = element_text(size = 15),
        axis.text = element_text(size = 12),
        legend.position = "right",
        legend.title = element_text(size = 13, face = "bold"),
        legend.text = element_text(size = 12)) +

  geom_path(data = all_param_gradient, aes(x = Phi, y = Alpha, color = Scenario),
              se = FALSE, linewidth = 1.35, inherit.aes = FALSE) +
  labs(color = "Parameter Values from 9°C-16°C") +
  scale_color_manual(values = c(
    "High Mismatch" = "black",
    "Mid 1 Mismatch" = "purple",
    "Mid 2 Mismatch" = "brown",
    "Mid 3 Mismatch" = "deeppink",
    "No Mismatch" = "pink"
  ))

phi_alpha_range_plot

#ggsave("Figures/phi_alpha_range_plot.png", plot = phi_alpha_range_plot,
#       device = "png", width = 10, height = 7, dpi = 300)
```


